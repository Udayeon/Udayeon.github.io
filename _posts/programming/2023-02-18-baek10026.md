---
layout: post
title: 
description: |
  Baekjoon 10026번 문제 '적록색약' - 그래프 이론, 그래프 탐색, 너비 우선 탐색, 깊이 우선 탐색
hide_image: true
tags:
  - programming
published: true
---

# (cpp) Baekjoon 10026번 문제 '적록색약' - 그래프 이론, 그래프 탐색, 너비 우선 탐색, 깊이 우선 탐색
* * *
[문제](https://www.acmicpc.net/problem/10026)   
   
# 예제입력1에 대한 문제풀이
![image](https://user-images.githubusercontent.com/69246778/219866304-ad69dc85-38f9-4b6a-aaef-515735e697bd.png)
**1. 시작점과 상하좌우로 인접한 지점들을 탐색하여 해당 지점과 같은 색깔이면 같은 그룹으로 분류되고, 그렇지 않으면 다른 그룹이 된다.
이떄, 색약이 있는 사람은 R과 G를 같은 그룹으로 본다.**  
   
**2. 색약 없는 사람의 check박스와 색약 있는 사람의 check박스를 각각 만든다.**   
   
**3. [1,1]을 시작큐에 넣었을 떄 탐색 후보군은 [1,2],[2,1]이 된다. check1[1][1]=1로 체크했을 때, [1,2]는
[1,1]과 같으므로 'check1[1][2]=check1[1][1]'이 되고, [2,1]은 [1,1]과 다르므로 'check1[2][1] = check1[1][1] + 1'
이 된다. 반면, 색약이 있는 사람의 check2의 경우 'check2[1][2] = check2[2][1] = check[1][1]' 이다.**   

**4. check를 구성하는 가장 큰 수를 각각 출력한다.**   

   
# 코드
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<queue>
using namespace std;

int m, n, h, state, g[101][101][101];
int result = 0;

// 왼,오,위,아,위층,아래층
int h_pos[6] = { 0,0,0,0,-1,1 };
int r_pos[6] = { 0,0,-1,1,0,0 };
int c_pos[6] = { -1,1,0,0,0,0 };

struct tomato {
	int h,r,c;
};
queue<tomato> q;



void solution() {

	while (!q.empty()) {
		int cur_h = q.front().h;
		int cur_r = q.front().r; 
		int cur_c = q.front().c;
		q.pop();

		for (int i = 0; i < 6; i++) {
			int next_h = cur_h + h_pos[i];
			int next_r = cur_r + r_pos[i];
			int next_c = cur_c + c_pos[i];
			if (0 < next_r && next_r <= n && 0 < next_c && next_c <= m && 0 < next_h && next_h <= h && g[next_h][next_r][next_c] == 0) {
				g[next_h][next_r][next_c] = g[cur_h][cur_r][cur_c] + 1;
				q.push({ next_h,next_r,next_c});
			}
		}
	}
}

int main() {
	cin >> m >> n >> h;
	for (int i = 1; i <= h ; i++) {
		for (int j = 1; j <= n; j++) {
			for (int k = 1; k <= m; k++) {
				cin >> state;
				g[i][j][k] = state;
				if (g[i][j][k] == 1) {
					q.push({ i,j,k }); //state가 1인 시작점 큐에 입력
				}
			}
		}
	}

	solution();

	for (int i = 1; i <= h; i++) {
		for (int j = 1; j <= n; j++) {
			for (int k = 1; k <= m; k++) {
				if (g[i][j][k] == 0) {
					cout << -1;
					return 0;
				}
				if (g[i][j][k] > result) {
					result = g[i][j][k];
				}

			}
		}
	}
	cout << result-1;
	return 0;
}
```   
* **반례 : 2 RGGR**

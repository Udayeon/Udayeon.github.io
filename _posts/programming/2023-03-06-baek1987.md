---
layout: post
title: 
description: |
  Baekjoon 1987번 문제 '알파벳' - 그래프이론, 그래프탐색, DFS, 백트래킹
hide_image: true
tags:
  - programming
published: true
---

# (cpp) Baekjoon 1987번 문제 '알파벳' - 그래프이론, 그래프탐색, DFS, 백트래킹
* * *
[문제](https://www.acmicpc.net/problem/1987)   
   
# 문제풀이

# 코드
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<queue>
#include<string>
#include<algorithm>
#include<vector>
using namespace std;

int r, c;
string al;
char board[22][22];
int board_check[22][22];
queue<pair<int, int>> q;
vector<char> check_al;

int r_pos[4] = { -1,1,0,0 };
int c_pos[4] = { 0,0,1,-1 };
int iter=1;

void solution(int init_r,int init_c) {
	q.push(make_pair(init_r,init_c));
	check_al.push_back(board[init_r][init_c]);
	while (!q.empty()) {
		int cur_r = q.front().first;
		int cur_c = q.front().second;
		q.pop();
		for (int i = 0; i < 4; i++) {
			int next_r = cur_r + r_pos[i];
			int next_c = cur_c + c_pos[i];
			int cnt = count(check_al.begin(), check_al.end(), board[next_r][next_c]);
			if (0 <= next_r && next_r < r && 0 <= next_c && next_c < c && cnt == 0) {
				check_al.push_back(board[next_r][next_c]);
				board_check[next_r][next_c] = board_check[cur_r][cur_c] + 1;
				//q.push(make_pair(next_r, next_c));
				solution(next_r, next_c);
			}
		}
		
	}

	
}
int main() {
	cin >> r;
	cin >> c;
	for (int i = 0; i < r; i++) {
		cin >> al;
		for (int j = 0; j < c; j++) {
			board[i][j] = al[j];
			board_check[i][j] = -1;
		}
	}

	board_check[0][0] = 0;
	solution(0,0);

	int max = -1;
	for (int i = 0; i < r; i++) {
		for (int j = 0; j < c; j++) {
			if (board_check[i][j] > max) {
				max = board_check[i][j];
			}
		}
	}
	cout << max;
	return 0;
}
```
* **공백없이 입력되는 n x m행렬로 2차원 배열로 저장하는 아이디어**

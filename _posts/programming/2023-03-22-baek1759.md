---
layout: post
title: 
description: |
  Baekjoon 1759번 문제 '암호 만들기 ' - 수학, 브루트포스, 백트래킹, 조합론
hide_image: true
tags:
  - programming
published: true
---

# (cpp) Baekjoon 1759번 문제 '암호 만들기 ' - 수학, 브루트포스, 백트래킹, 조합론
* * *
[문제](https://www.acmicpc.net/problem/1759)   
   
# 예제입력1에 대한 문제풀이
입력
```
4 6
a t c i s w
```
모음 : a i   
자음 : t c s w   
위의 자모음 각각을 오름차순 정렬하면 아래와 같다.   
모음 : a i   
자음 : c s t w   
   
암호를 만들 때 필요한 알파벳 4개를 먼저 선정하는데 모음 1개 이상, 자음 2개 이상의 경우의 수를 고려해야 한다.   
순서는 고려하지 않고 가능한 조합을 생각해보면
* 모음 1개, 자음 3개 (a,c,s,t) (a,c,s,w) (a,c,t,w) (a,s,t,w) (i,c,s,t) (i,c,s,w) (i,c,t,w) (i,s,t,w) 
* 모음 2개, 자음 2개 (a,i,c,s) (a,i,c,t) (a,i,c,w) (a,i,s,t) (a,i,s,w) (a,i,t,w)   
각 경우의 수에 대해서 오름차순 정렬하여 출력한다. 

# 코드
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
int n,answer;
int s[100000];


void solution() {
	priority_queue<int> q; //내림차순 [8 7 6 5]
	for (int i = 0; i < n; i++) {
		q.push(-s[i]); //오름차순으로 정렬되게 - 붙여서 넣기 [-5 -6 -7 -8]

	}
	while (q.size()!=1) {
	
		int num1 = -q.top(); //11
		q.pop();
		int num2 = -q.top(); //15
 		q.pop(); // q=[]
		answer = answer + (num1 + num2);
		q.push(-(num1 + num2)); //q=[-26]

	}
	cout << answer;
}
int main() {
	cin >> n; //숫자카드 묶음 갯수 (1 <= n <= 100,000 정수) 
	for (int i = 0; i < n; i++) {
		cin >> s[i];

	}
	solution();
	return 0;
}
```
* **단지 순차적으로 계산하면 안되고, 카드 뭉치 합칠 때마다 합칠 카드 뭉치 후보를 갱신해주어야 함.**
* **우선순위 큐를 활용하는데 오름차순 정렬을 위해 push하는 요소에 마이너스를 붙여준다.**

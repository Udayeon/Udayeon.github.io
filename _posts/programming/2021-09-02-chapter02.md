---
layout: post
title: (Python) 파이썬과 Opencv를 이용한 컴퓨터 비전 학습 Chapter02
description: |
  Opencv3 computer vision with python cookbook
hide_image: true
tags:
  - programming
published: true
---

# (Python) 파이썬과 Opencv를 이용한 컴퓨터 비전 학습 Chapter02

(Python) 파이썬과 Opencv를 이용한 컴퓨터 비전 학습 Chapter02

# Chapter02.행렬,색상,필터
* * * 
행렬로 작업하는 방법에 대해 살펴본다. 픽셀 단위의 행렬을 사용해 수행하는 작업과 행렬 전체에 적용할 수 있는 연산 및 이미지 처리 절차에 대해 학습한다.

## 1. 행렬 조작: 생성하기, 채우기, 요소 접근하기, ROI

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np

image = np.full((480,640,3),255,np.uint8)

cv2.imshow('white',image)
cv2.waitKey()
cv2.destroyAllWindows()

image = np.full((480,640,3),(0,0,255),np.uint8)
cv2.imshow('red',image)
cv2.waitKey()
cv2.destroyAllWindows()

image.fill(0)
cv2.imshow('black',image)
cv2.waitKey()
cv2.destroyAllWindows()

image[240,160] =image[240,320] = image[240,48]=(255,255,255)
cv2.imshow('black with white pixels',image)
cv2.waitKey()
cv2.destroyAllWindows()

image[:,:,0] = 255
cv2.imshow('blue wiht white pixels',image)
cv2.waitKey()
cv2.destroyAllWindows()

image[:,320,:]=255
cv2.imshow('blue with white line', image)
cv2.waitKey()
cv2.destroyAllWindows()
```
![스크린샷, 2021-09-14 12-06-00](https://user-images.githubusercontent.com/69246778/133188371-859a4a7d-cc97-41c6-9995-098363bfc92c.png)
![스크린샷, 2021-09-14 12-07-00](https://user-images.githubusercontent.com/69246778/133188376-7d8f43f1-e852-4d4e-92be-81557f222404.png)
![스크린샷, 2021-09-14 12-07-10](https://user-images.githubusercontent.com/69246778/133188436-5d6cc2ee-e643-42b5-b991-4ed9b6946635.png)
![스크린샷, 2021-09-14 12-07-21](https://user-images.githubusercontent.com/69246778/133188471-84c99049-6186-4e8b-94ff-76de220349f1.png)
![s](https://user-images.githubusercontent.com/69246778/133188493-3cbcd497-a30b-488f-bf82-1f4dda735989.png)
![스크린샷, 2021-09-14 12-07-39](https://user-images.githubusercontent.com/69246778/133188502-f2b48e3f-cfd2-429f-a796-d99e2647b540.png)

                          
## 2. 데이터 타입과 스케일 변환
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np
image = cv2.imread('../data/Lena.png')
print('Shape:',image.shape)
print('Data type:', image.dtype)

cv2.imshow('image',image)
cv2.waitKey()
cv2.destroyAllWindows()


# 이미지를 부동소수점 데이터 타입으로 변환
image  = image.astype(np.float32)/255
print('Shape:',image.shape)
print('Data type:',image.dtype)


# 이미지의 요소를 2배로 스케일링하고 해당 값을 [0,1]범위로 조절
cv2.imshow('image', np.clip(image*2,0,1))
cv2.waitKey()
cv2.destroyAllWindows()

#이미지의 요소를 다시 [0,255]범위로 조절하고 요소 데이터 타입을 uint8로 변환
image = (image*255).astype(np.uint8)
print('Shape:',image.shape)
print('Datat type:', image.dtype)

cv2.imshow('image',image)
cv2.waitKey()
cv2.destroyAllWindows()
```

```
>>>
Shape: (512, 512, 3)
Data type: uint8
Shape: (512, 512, 3)
Data type: float32
Shape: (512, 512, 3)
Datat type: uint8
```

![스크린샷, 2021-09-14 12-11-47](https://user-images.githubusercontent.com/69246778/133188839-6997bc80-6dab-4baf-a052-7761f7e7190f.png)
![스크린샷, 2021-09-14 12-12-00](https://user-images.githubusercontent.com/69246778/133188845-ccea3bbe-b13d-442a-96ea-dd1699ac9a1a.png)
![스크린샷, 2021-09-14 12-12-12](https://user-images.githubusercontent.com/69246778/133188849-d0bbe7ce-1a90-41d1-b4e3-bf62a15ad2d0.png)

## 3. NumPy를 사용한 비이미지 데이터 영속성
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np

#임의의 값으로 초기화된 행렬을 생성하고 속성을 출력
mat=np.random.rand(100,100).astype(np.float32)
print('Shape:',mat.shape)
print('Data type:',mat.dtype)

#앞에서 생성한 행렬을 저장
np.savetxt('mat.csv',mat)

#저장한 파일을 다시 불러와 shape와 type출력
mat = np.loadtxt('mat.csv').astype(np.float32)
print('Shape:',mat.shape)
print('Data type:',mat.dtype)
```
```
>>>
Shape: (100, 100)
Data type: float32
Shape: (100, 100)
Data type: float32
```

## 4. 이미지 채널 조작
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np
image = cv2.imread('../data/Lena.png').astype(np.float32)/255
print('Shape:',image.shape)


#적색과 청색 채널을 서로 바꾼다
image[:,:,[0,2]]=image[:,:,[2,0]]
cv2.imshow('blue_and_red_swapped',image)
cv2.waitKey()
cv2.destroyAllWindows()


#원래대로 채널을 다시 바꾸고 이미지의 채색을 바꾸기 위해 다양한 스케일을 적용한다
image[:,:,[0,2]] = image[:,:,[2,0]]
image[:,:,0] = (image[:,:,0]*0.9).clip(0,1)
image[:,:,1] = (image[:,:,1]*1.1).clip(0,1)

cv2.imshow('image',image)
cv2.waitKey()
cv2.destroyAllWindows()
```
```
>>>
Shape: (512, 512, 3)
```

![스크린샷, 2021-09-14 12-17-28](https://user-images.githubusercontent.com/69246778/133189321-100e5f95-d620-491c-bc41-386b3067335d.png)
![스크린샷, 2021-09-14 12-17-35](https://user-images.githubusercontent.com/69246778/133189329-f14b0333-eeea-4ab2-ba53-8630197804a2.png)

## 5. 이미지의 색 공간 변환
[HSV](https://ko.wikipedia.org/wiki/HSV_%EC%83%89_%EA%B3%B5%EA%B0%84)

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np

image = cv2.imread('../data/Lena.png').astype(np.float32)/255
print('Shape:',image.shape)
print('Data type:',image.dtype)

#이미지를 그레이 스케일로 변환한다
gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
print('Converted to grayscale')
print('Shape:',gray.shape)
print('Data type:',gray.dtype)
cv2.imshow('gray',gray)
cv2.waitKey()
cv2.destroyAllWindows()

#이미지를 HSV색 공간으로 변환한다
hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)
print('Converted to HSV')
print('Shape:',hsv.shape)
print('Data type:',hsv.dtype)
cv2.imshow('HSV',hsv)
cv2.waitKey()
cv2.destroyAllWindows()

#V채널에 값을 곱해 이미지의 밝기를 높이고 나서 이미지를 RGB색 공간으로 변환한다.
hsv[:,:,2]*=2
from_hsv=cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)
print('Converted back to BGR from HSV')
print('Shape:',from_hsv.shape)
print('Data type:',from_hsv.dtype)
cv2.imshow('from_hsv',from_hsv)
cv2.waitKey()
cv2.destroyAllWindows()
```
```
>>>
Shape: (512, 512, 3)
Data type: float32
Converted to grayscale
Shape: (512, 512)
Data type: float32
Converted to HSV
Shape: (512, 512, 3)
Data type: float32
Converted back to BGR from HSV
Shape: (512, 512, 3)
Data type: float32
```
![스크린샷, 2021-09-14 12-19-23](https://user-images.githubusercontent.com/69246778/133189467-317d3983-1809-46e5-803e-644b28875e35.png)
![스크린샷, 2021-09-14 12-19-28](https://user-images.githubusercontent.com/69246778/133189466-d7c268eb-28a7-4335-a8f8-e53e1c1a82ce.png)
![스크린샷, 2021-09-14 12-19-34](https://user-images.githubusercontent.com/69246778/133189463-e04adb7e-a5e1-4f59-a314-e86e74b5f0c6.png)


## 6. 감마 보정과 요소 단위의 수학
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np
image = cv2.imread('../data/Lena.png').astype(np.float32)/255

#지정된 지수값인 gamma를 사용해 요소당 지수를 적용한다
gamma = 0.5
corrected_image  = np.power(image,gamma)

cv2.imshow('image',image)
cv2.imshow('corrected_image',corrected_image)
cv2.waitKey()
cv2.destroyAllWindows()
```
![스크린샷, 2021-09-14 12-22-43](https://user-images.githubusercontent.com/69246778/133189787-b1aa08c6-86ee-48d8-9cc2-084ee9947472.png)

## 7. 평균/분산 이미지 정규화
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-


import cv2, numpy as np

image=cv2.imread('../data/Lena.png').astype(np.float32)/255

#각 이미지 픽셀에서 평균을 빼 제로 평균 행렬을 구함
image -=image.mean()

#위에서 구한 행렬에서 각 픽셀값을 표준편차로 나눠 단위 분산 행렬을 구함
image /=image.std()
```

## 8. 이미지 히스토그램 계산
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np
import matplotlib.pyplot as plt

grey = cv2.imread('../data/Lena.png',0)
cv2.imshow('original grey',grey)
cv2.waitKey()
cv2.destroyAllWindows()


#histogram함수로 계산
hist,bins = np.histogram(grey, 256, [0,255])

#히스토그램을 화면에 표시
plt.fill(hist)
plt.xlabel('pixel value')
plt.show()
```
![스크린샷, 2021-09-14 12-24-19](https://user-images.githubusercontent.com/69246778/133189969-6843b32b-706a-46c2-8a98-fac4e4369cdd.png)
![스크린샷, 2021-09-14 12-24-29](https://user-images.githubusercontent.com/69246778/133189974-74db17b6-81bc-4d69-a03d-7eefbfa3186b.png)

## 9. 이미지 [히스토그램의 평활화](https://opencv-python.readthedocs.io/en/latest/doc/20.imageHistogramEqualization/imageHistogramEqualization.html)
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np
import matplotlib.pyplot as plt

#이미지를 greyscale로 불러와서 화면에 표시
grey = cv2.imread('../data/Lena.png',0)
cv2.imshow('original grey',grey)
cv2.waitKey()
cv2.destroyAllWindows()

#greyscale 이미지의 히스토그램을 평활화
grey_eq = cv2.equalizeHist(grey)

#평활화된 이미지의 히스토그램을 계산하고 그래프를 표시
hist,bins = np.histogram(grey_eq,256,[0,255])
plt.fill_between(range(256),hist,0)
plt.xlabel('pixel value')
plt.show()

#평활화 된 이미지를 화면에 표시
cv2.imshow('equalized grey',grey_eq)
cv2.waitKey()
cv2.destroyAllWindows()

#BGR로 이미지를 불러와서 HSV색 공간으로 변환
color = cv2.imread('../data/Lena.png')
hsv = cv2.cvtColor(color,cv2.COLOR_BGR2HSV)

#HSV이미지의 V채널을 평활화하고 다시 BGR공간으로 변환(V:명도)
hsv[...,2] = cv2.equalizeHist(hsv[...,2])
color_eq = cv2.cvtColor(hsv,cv2.COLOR_HSV2BGR)

cv2.imshow('original color',color)
cv2.imshow('equalized color',color_eq)
cv2.waitKey()
cv2.destroyAllWindows()
```

![스크린샷, 2021-09-14 12-47-12](https://user-images.githubusercontent.com/69246778/133192181-e1b3f40f-22e8-4fff-8832-89ac53341122.png)
![스크린샷, 2021-09-14 12-47-24](https://user-images.githubusercontent.com/69246778/133192177-9c59c0f5-b056-4039-a4d8-c8baa70d6467.png)
![스크린샷, 2021-09-14 12-47-43](https://user-images.githubusercontent.com/69246778/133192175-ccd6c1e8-ff51-4048-982b-55ac63c95004.png)
![스크린샷, 2021-09-14 12-51-02](https://user-images.githubusercontent.com/69246778/133192172-22e3abac-7861-482f-b05c-d3185b263372.png)

## 10. 가우시안 필터, 중앙값 필터, 양방향 필터를 사용한 노이즈 제거
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np
import matplotlib.pyplot as plt

image = cv2.imread('../data/Lena.png').astype(np.float32)/255

#이미지에 노이즈 생성하기
noised = (image + 0.2*np.random.rand(*image.shape).astype(np.float32))
noised = noised.clip(0,1)

plt.imshow(noised[:,:,[2,1,0]])
plt.show()

#노이즈가 있는 이미지에 가우시안 필터 적용
gauss_blur = cv2.GaussianBlur(noised,(7,7),0)
plt.imshow(gauss_blur[:,:,[2,1,0]])
plt.show()

#노이즈가 있는 이미지에 medianBlur 적용
median_blur = cv2.medianBlur((noised*255).astype(np.uint8),7)
plt.imshow(median_blur[:,:,[2,1,0]])
plt.show()

#노이즈가 있는 이미지에 bilateralFilter 적용
bilat = cv2.bilateralFilter(noised,-1,0.3,10)
plt.imshow(bilat[:,:,[2,1,0]])
plt.show()
```
* noised
![스크린샷, 2021-09-14 13-08-09](https://user-images.githubusercontent.com/69246778/133193481-74fc5047-a064-43a0-a06c-c47d58496509.png)
* 가우시안
![스크린샷, 2021-09-14 13-08-43](https://user-images.githubusercontent.com/69246778/133193525-86add54f-ae4d-47fd-b5b4-c0822212b87d.png)
* medianblur
![스크린샷, 2021-09-14 13-08-57](https://user-images.githubusercontent.com/69246778/133193538-8253f736-ffc9-4190-b39d-354b64436a83.png)
* bilateralfilter
![스크린샷, 2021-09-14 13-09-17](https://user-images.githubusercontent.com/69246778/133193552-27d50aa6-55a7-45d7-b749-7c0f98ed43ac.png)


## 11. 소벨 필터로 이미지 경사도 계산
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2
import numpy as np
import matplotlib.pyplot as plt

image = cv2.imread('../data/Lena.png',0)

dx = cv2.Sobel(image,cv2.CV_32F,1,0)
dy = cv2.Sobel(image,cv2.CV_32F,0,1)

plt.figure(figsize=(8,3))
plt.subplot(131)
plt.axis('off')
plt.title('image')
plt.imshow(image,cmap='gray')


plt.subplot(132)
plt.axis('off')
plt.title(r'$\frac{dI}{dx}$')
plt.imshow(dx,cmap='gray')

plt.subplot(133)
plt.axis('off')
plt.title(r'$\frac{dI}{dy}$')
plt.imshow(dy,cmap='gray')

plt.tight_layout()
plt.show()
```
![스크린샷, 2021-09-14 13-19-54](https://user-images.githubusercontent.com/69246778/133194453-ec73ffb9-5515-4f91-a70c-b7a1057ab069.png)

## 12. 자체 필터 생성과 적용
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np
import math
import matplotlib.pyplot as plt

image = cv2.imread('../data/Lena.png')

#11x11크기의 선명화 커널을 생성한다.
KSIZE = 11
ALPHA = 2

kernel = cv2.getGaussianKernel(KSIZE,0)
kernel = -ALPHA*kernel @kernel.T
kernel[KSIZE//2,KSIZE//2]+=1+ALPHA

#생성한 커널로 이미지를 필터링한다.
filtered =cv2.filter2D(image,-1,kernel)

#결과 시각화
plt.figure(figsize=(8,4))
plt.subplot(121)
plt.axis('off')
plt.title('image')
plt.imshow(image[:,:,[2,1,0]])

plt.subplot(122)
plt.axis('off')
plt.title('filtered')
plt.imshow(filtered[:,:,[2,1,0]])

plt.tight_layout(True)  #자동으로 여백 조정 
plt.show()
```
![스크린샷, 2021-09-14 13-31-21](https://user-images.githubusercontent.com/69246778/133195310-1bc83efe-44c1-42a2-8eb0-1f273a552a70.png)

## 13. 실수 값으로 된 가버 필터로 이미지 처리
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np
import math
import matplotlib.pyplot as plt

image = cv2.imread('../data/Lena.png',0).astype(np.float32)/255

#가버커널 구성
kernel=cv2.getGaborKernel((21,21),5,1,10,1,0,cv2.CV_32F)
kernel /=math.sqrt((kernel*kernel).sum())

#이미지를 필터링한다
filtered =cv2.filter2D(image,-1,kernel)

plt.figure(figsize=(8,3))
plt.subplot(131)
plt.axis('off')
plt.title('image')
plt.imshow(image,cmap='gray')


plt.subplot(132)
plt.title('kernel')
plt.imshow(kernel,cmap='gray')

plt.subplot(133)
plt.title('filtered')
plt.axis('off')
plt.imshow(filtered,cmap='gray')

plt.tight_layout(True)
plt.show()
```
![스크린샷, 2021-09-14 13-38-47](https://user-images.githubusercontent.com/69246778/133195886-26a8295f-ff80-4184-805d-c449ba9bb1d4.png)


## 14. 이산 푸리에 변환을 사용한 공간 도메인과 주파수 도메인 간 변환
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2, numpy as np
import matplotlib.pyplot as plt

image = cv2.imread('../data/Lena.png',0).astype(np.float32)/255

#이산 푸리에 변환을 적용한다
fft = cv2.dft(image, flags =cv2.DFT_COMPLEX_OUTPUT)

#이미지 스펙트럼을 시작한다.
shifted = np.fft.fftshift(fft,axes=[0,1])
magnitude = cv2.magnitude(shifted[:,:,0],shifted[:,:,1])
magnitude = np.log(magnitude)


plt.axis('off')
plt.imshow(magnitude,cmap='gray')
plt.tight_layout(True)
plt.show()


#이미지를 주파수 스펙트럼에서 다시 공간 표현으로 변환
restored = cv2.idft(fft,flags=cv2.DFT_SCALE | cv2.DFT_REAL_OUTPUT)
```
![스크린샷, 2021-09-14 13-46-12](https://user-images.githubusercontent.com/69246778/133196521-12f1471c-fae8-4fcc-a479-1f04a8e76535.png)

## 15. 이미지 필터링을 위한 이미지 주파수 조작

---
layout: post
title: 
description: |
  Baekjoon 18352번 문제 '특정 거리의 도시 찾기' - 그래프 탐색, BFS, 다익스트라
hide_image: true
tags:
  - programming
published: true
---

# (cpp) Baekjoon 18352번 문제 '특정 거리의 도시 찾기' - 그래프 탐색, BFS, 다익스트라
* * *
[문제](https://www.acmicpc.net/problem/18352)
# 풀이
```cpp
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

int n, m, k, x, from, to;
vector<vector<int>> g;
vector<int> check_bfs;
vector<int> result;


void bfs() {
	int start = x;
	queue<int> q;
	q.push(x); //다녀온 곳 기록할 큐, 다녀오고 나면 비워줄 것. 
	check_bfs[x] = 0;

	while (!q.empty()) {
		int cur = q.front(); //현재 정점은 항상 큐의 맨 앞 요소
		q.pop(); //현재 위치 기억만 해두고 큐는 비우기
		
		for (int i = 0; i < g[cur].size(); i++) {
			//현재 위치에서 갈 수 있는 지점의 수
			int next = g[cur][i]; //현재그래프에 포함된 모든 점이 next지점의 후보
			if (check_bfs[next] == -1) {
				//그치만 가본적 없는 곳이여야 함.
				check_bfs[next] = check_bfs[cur] + 1; //가서 체크하고
				q.push(next); //그 지점이 새로운 시작점이 됨
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		if (check_bfs[i] == k) {
			result.push_back(i);
		}
	}
}

int main() {
	cin >> n;
	cin >> m;
	cin >> k;
	cin >> x;
	g = vector<vector<int> >(n + 1);
	check_bfs= vector<int>(n + 1, -1);
	for (int i = 0; i < m; i++) {
		cin >> from >> to;
		g[from].push_back(to);
	}

	bfs();
	if (result.size() == 0) {
		cout << -1;
	}
	else 
	{
		for (int i = 0; i < result.size(); i++) {
			cout << result[i] << '\n';
		}
	}	
}
```
